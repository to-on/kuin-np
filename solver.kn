+class Solver()
  const box_x: int :: 3
  const box_y: int :: 2
  const board_size: int :: box_x * box_y
  const cell_size: int :: board_size * board_size

  var candidates: []bit16
  var answer: []int
  var emptyCellCount: int
  var noSolutionFlag: bool

  +func printPuzzle(puz: []int)
    ; size
    if (^puz <> cell_size)
      do cui@print("error puz size : \{^puz}\n")
      ret
    end if

    ; bar
    var bar: []char :: "+"
    for (1, box_y)
      for (1, box_x)
        do bar:~ "-"
      end for
      do bar:~ "+"
    end for
    do bar:~ "\n"

    ; print
    for j(0, board_size - 1)
      if (j % box_y = 0)
        do cui@print("\{bar}")
      end if
      for i(0, board_size - 1)
        if (i % box_x = 0)
          do cui@print("|")
        end if
        var p: int :: i + j * board_size
        do cui@print("\{puz[p]}")
      end for
      do cui@print("|\n")
    end for
    do cui@print("\{bar}")
  end func

  +func printCandidates()
    for j(0, board_size - 1)
      for by(0, box_y - 1)
        for i(0, board_size - 1)
          var p: int :: i + j * board_size
          for bx(0, box_x - 1)
            var n: int :: bx + by * box_x
            if (me.candidates[p].and(1b16.shl(n)) <> 0b16)
              do cui@print("\{n + 1}")
            else
              do cui@print(" ")
            end if
          end for
          do cui@print(" ")
        end for
        do cui@print("\n")
      end for
    end for
  end func

  func init()
    do me.candidates :: #[cell_size]bit16
    for i(0, ^me.candidates - 1)
      do me.candidates[i] :: 0b16.not().shr(16 - board_size)
    end for
    do me.answer :: #[cell_size]int
    do me.emptyCellCount :: 0
    do me.noSolutionFlag :: false
  end func

  *func ctor()
    do me.init()
  end func

  func deleteCandidate()
  end func
  func putNumber()
  end func
  func setPuzzle()
  end func
  func calcScore()
  end func
end class
